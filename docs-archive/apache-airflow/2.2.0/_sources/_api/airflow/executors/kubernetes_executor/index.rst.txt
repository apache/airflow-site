:mod:`airflow.executors.kubernetes_executor`
============================================

.. py:module:: airflow.executors.kubernetes_executor

.. autoapi-nested-parse::

   KubernetesExecutor

   .. seealso::
       For more information on how the KubernetesExecutor works, take a look at the guide:
       :ref:`executor:KubernetesExecutor`



Module Contents
---------------

.. data:: KubernetesJobType
   

   

.. data:: KubernetesResultsType
   

   

.. data:: KubernetesWatchType
   

   

.. py:class:: ResourceVersion

   Singleton for tracking resourceVersion from Kubernetes

   .. attribute:: resource_version
      :annotation: = 0

      

   
   .. classmethod:: __new__(cls)




.. py:class:: KubernetesJobWatcher(namespace: Optional[str], multi_namespace_mode: bool, watcher_queue: 'Queue[KubernetesWatchType]', resource_version: Optional[str], scheduler_job_id: Optional[str], kube_config: Configuration)

   Bases: :class:`multiprocessing.Process`, :class:`airflow.utils.log.logging_mixin.LoggingMixin`

   Watches for Kubernetes jobs

   
   .. method:: run(self)

      Performs watching



   
   .. method:: process_error(self, event: Any)

      Process error response



   
   .. method:: process_status(self, pod_id: str, namespace: str, status: str, annotations: Dict[str, str], resource_version: str, event: Any)

      Process status response




.. py:class:: AirflowKubernetesScheduler(kube_config: Any, task_queue: 'Queue[KubernetesJobType]', result_queue: 'Queue[KubernetesResultsType]', kube_client: client.CoreV1Api, scheduler_job_id: str)

   Bases: :class:`airflow.utils.log.logging_mixin.LoggingMixin`

   Airflow Scheduler for Kubernetes

   
   .. method:: run_pod_async(self, pod: k8s.V1Pod, **kwargs)

      Runs POD asynchronously



   
   .. method:: run_next(self, next_job: KubernetesJobType)

      The run_next command will check the task_queue for any un-run jobs.
      It will then create a unique job-id, launch that job in the cluster,
      and store relevant info in the current_jobs map so we can track the job's
      status



   
   .. method:: delete_pod(self, pod_id: str, namespace: str)

      Deletes POD



   
   .. method:: sync(self)

      The sync function checks the status of all currently running kubernetes jobs.
      If a job is completed, its status is placed in the result queue to
      be sent back to the scheduler.

      :return:



   
   .. method:: process_watcher_task(self, task: KubernetesWatchType)

      Process the task by watcher.



   
   .. method:: terminate(self)

      Terminates the watcher.




.. function:: get_base_pod_from_template(pod_template_file: Optional[str], kube_config: Any) -> k8s.V1Pod
   Reads either the pod_template_file set in the executor_config or the base pod_template_file
   set in the airflow.cfg to craft a "base pod" that will be used by the KubernetesExecutor

   :param pod_template_file: absolute path to a pod_template_file.yaml or None
   :param kube_config: The KubeConfig class generated by airflow that contains all kube metadata
   :return: a V1Pod that can be used as the base pod for k8s tasks


.. py:class:: KubernetesExecutor

   Bases: :class:`airflow.executors.base_executor.BaseExecutor`, :class:`airflow.utils.log.logging_mixin.LoggingMixin`

   Executor for Kubernetes

   
   .. method:: clear_not_launched_queued_tasks(self, session=None)

      Tasks can end up in a "Queued" state through either the executor being
      abruptly shut down (leaving a non-empty task_queue on this executor)
      or when a rescheduled/deferred operator comes back up for execution
      (with the same try_number) before the pod of its previous incarnation
      has been fully removed (we think).

      This method checks each of those tasks to see if the corresponding pod
      is around, and if not, and there's no matching entry in our own
      task_queue, marks it for re-execution.



   
   .. method:: start(self)

      Starts the executor



   
   .. method:: execute_async(self, key: TaskInstanceKey, command: CommandType, queue: Optional[str] = None, executor_config: Optional[Any] = None)

      Executes task asynchronously



   
   .. method:: sync(self)

      Synchronize task state.



   
   .. method:: try_adopt_task_instances(self, tis: List[TaskInstance])



   
   .. method:: adopt_launched_task(self, kube_client: client.CoreV1Api, pod: k8s.V1Pod, pod_ids: Dict[TaskInstanceKey, k8s.V1Pod])

      Patch existing pod so that the current KubernetesJobWatcher can monitor it via label selectors

      :param kube_client: kubernetes client for speaking to kube API
      :param pod: V1Pod spec that we will patch with new label
      :param pod_ids: pod_ids we expect to patch.



   
   .. method:: end(self)

      Called when the executor shuts down



   
   .. method:: terminate(self)

      Terminate the executor is not doing anything.




