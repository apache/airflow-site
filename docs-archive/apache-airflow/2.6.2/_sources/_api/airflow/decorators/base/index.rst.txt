:py:mod:`airflow.decorators.base`
=================================

.. py:module:: airflow.decorators.base


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   airflow.decorators.base.DecoratedOperator
   airflow.decorators.base.DecoratedMappedOperator
   airflow.decorators.base.Task
   airflow.decorators.base.TaskDecorator



Functions
~~~~~~~~~

.. autoapisummary::

   airflow.decorators.base.get_unique_task_id
   airflow.decorators.base.task_decorator_factory



Attributes
~~~~~~~~~~

.. autoapisummary::

   airflow.decorators.base.FParams
   airflow.decorators.base.FReturn
   airflow.decorators.base.OperatorSubclass


.. py:function:: get_unique_task_id(task_id, dag = None, task_group = None)

   Generate unique task id given a DAG (or if run in a DAG context).

   IDs are generated by appending a unique number to the end of
   the original task id.

   Example:
     task_id
     task_id__1
     task_id__2
     ...
     task_id__20


.. py:class:: DecoratedOperator(*, python_callable, task_id, op_args = None, op_kwargs = None, multiple_outputs = False, kwargs_to_upstream = None, **kwargs)


   Bases: :py:obj:`airflow.models.baseoperator.BaseOperator`

   Wraps a Python callable and captures args/kwargs when called for execution.

   :param python_callable: A reference to an object that is callable
   :param op_kwargs: a dictionary of keyword arguments that will get unpacked
       in your function (templated)
   :param op_args: a list of positional arguments that will get unpacked when
       calling your callable (templated)
   :param multiple_outputs: If set to True, the decorated function's return value will be unrolled to
       multiple XCom values. Dict will unroll to XCom values with its keys as XCom keys. Defaults to False.
   :param kwargs_to_upstream: For certain operators, we might need to upstream certain arguments
       that would otherwise be absorbed by the DecoratedOperator (for example python_callable for the
       PythonOperator). This gives a user the option to upstream kwargs as needed.

   .. py:attribute:: template_fields
      :type: Sequence[str]
      :value: ('op_args', 'op_kwargs')

      

   .. py:attribute:: template_fields_renderers

      

   .. py:attribute:: shallow_copy_attrs
      :type: Sequence[str]
      :value: ('python_callable',)

      

   .. py:method:: execute(context)

      This is the main method to derive when creating an operator.
      Context is the same dictionary used as when rendering jinja templates.

      Refer to get_template_context for more context.


   .. py:method:: get_python_source()



.. py:data:: FParams

   

.. py:data:: FReturn

   

.. py:data:: OperatorSubclass

   

.. py:class:: DecoratedMappedOperator(context=None)


   Bases: :py:obj:`airflow.models.mappedoperator.MappedOperator`

   MappedOperator implementation for @task-decorated task function.

   .. py:attribute:: multiple_outputs
      :type: bool

      

   .. py:attribute:: python_callable
      :type: Callable

      

   .. py:attribute:: op_kwargs_expand_input
      :type: airflow.models.expandinput.ExpandInput

      

   .. py:method:: __hash__()

      Return hash(self).


   .. py:method:: __attrs_post_init__()



.. py:class:: Task


   Bases: :py:obj:`airflow.typing_compat.Protocol`, :py:obj:`Generic`\ [\ :py:obj:`FParams`\ , :py:obj:`FReturn`\ ]

   Declaration of a @task-decorated callable for type-checking.

   An instance of this type inherits the call signature of the decorated
   function wrapped in it (not *exactly* since it actually returns an XComArg,
   but there's no way to express that right now), and provides two additional
   methods for task-mapping.

   This type is implemented by ``_TaskDecorator`` at runtime.

   .. py:property:: __wrapped__
      :type: Callable[FParams, FReturn]


   .. py:attribute:: __call__
      :type: Callable[FParams, airflow.models.xcom_arg.XComArg]

      

   .. py:attribute:: function
      :type: Callable[FParams, FReturn]

      

   .. py:method:: partial(**kwargs)


   .. py:method:: expand(**kwargs)


   .. py:method:: expand_kwargs(kwargs, *, strict = True)


   .. py:method:: override(**kwargs)



.. py:class:: TaskDecorator


   Bases: :py:obj:`airflow.typing_compat.Protocol`

   Type declaration for ``task_decorator_factory`` return type.

   .. py:method:: __call__(python_callable: Callable[FParams, FReturn]) -> Task[FParams, FReturn]
                  __call__(*, multiple_outputs: bool | None = None, **kwargs: Any) -> Callable[[Callable[FParams, FReturn]], Task[FParams, FReturn]]

      For the decorator factory ``@task()`` case.


   .. py:method:: override(**kwargs)



.. py:function:: task_decorator_factory(python_callable = None, *, multiple_outputs = None, decorated_operator_class, **kwargs)

   Generate a wrapper that wraps a function into an Airflow operator.

   Can be reused in a single DAG.

   :param python_callable: Function to decorate.
   :param multiple_outputs: If set to True, the decorated function's return
       value will be unrolled to multiple XCom values. Dict will unroll to XCom
       values with its keys as XCom keys. If set to False (default), only at
       most one XCom value is pushed.
   :param decorated_operator_class: The operator that executes the logic needed
       to run the python function in the correct environment.

   Other kwargs are directly forwarded to the underlying operator class when
   it's instantiated.


